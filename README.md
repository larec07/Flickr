# Flickr.

[Задание](https://github.com/larec07/Flickr/blob/master/Задание.pdf)

### Вступление

- В выборе социальных сетей остановился на [Flickr](https://www.flickr.com). 
  [Документация Flickr API](https://www.flickr.com/services/api/).
  Сервис для получения последних опубликованных фотографий - API method [flickr.photos.getRecent](https://www.flickr.com/services/api/flickr.photos.getRecent.html)

- Для работы с сетью была использована библиотека [Alamofire](https://github.com/Alamofire/Alamofire). Для кэширования изображений - [AlamofireImage](https://github.com/Alamofire/AlamofireImage). Работа со сторонними фрэймворками и библиотеками реализована посредством пакетного менеджера Cocoa Pods.

### Описание работы приложения

Приложение представляет последние опубликованные на сервисе Flickr фотографии с короткими подписями. Контент представлен таблицей в 3 столбца. Каждый элемент таблицы имеет соотношение сторон 4:3. Картинки размещаются по принципу `Aspect Fit`. Скачивает порциями по 40 штук. Пользователь имеет возможность обновить список (pull to refresh). Также по достижении конца списка - "запрашивается" очередная порция данных. "Самая верхняя часть" контента, размером в запрашиваемую порцию, последней сессии сохраняется и при последующем запуске пользователю представится именно эта часть.

Несколько неоднозначным в постановке задачи мне показался пункт
"`данные из первого запроса кэшируются, а при перезапуске приложения показываются старые данные и запрашиваются актуальные данные;`"
  Я растолковал это так: небходимо сохранять первую порцию фотографий последней сессии и показать их при очередном        перезапуске. Тогда не ясно - в какой момент запрашивать свежие фото, будучи в режиме просмотра фото с предыдущей сессии. Решил запрашивать свежие, как только пользователь "запросит" обновления списка (pull to refresh). Т.е. сценарий такой: пользователь, запустив приложение, видит 40 фотографий, сохраненных с последней сессии (самых свежих), чтобы выйти из режима просмотра старых фото и начать просматривать актуальные данные нужно применить контрол pull to refresh, ранее упомянутые 40 фотографий с последней сессии будут стерты и будет запрошена и показана порция новых фотографий в 40 единиц и будет доступна дозагрузка.

### Комментарии к некоторым техническим решениям

- Приложение небольшое, поэтому придерживаться многослойного архитектурного паттерна, вроде VIPER, было бы слишком накладно. В случае многослойной архитектуры каждый слой был бы минимально("излишне" минимально) нагружен, в то же время распределение ролей и выработка регламента коммуникаций между ними потребовало бы значительных усилий в сравнении с усилиями, затраченными на реализацию бизнес-логики и сопутствующего функционала. Ввиду описанного, счел целесообразным не отходить далеко от Apple MVC, но разгрузить ViewController, выделив презентационную часть в отдельный блок, который, помимо прочего, реализует бизнес-логику. Остановился на MVP.

- При обновлении (pull to refresh) можно было и не очищать кэш, в случае идентичности данных локальных и полученых от сервера можно избежать перезаписи. Решил сделать так, потому как данные очень живо обновляются на сервере, а порции запрашиваемых фотографий очень невелики (40 штук).

- Необработан случай отсутствия доступа к сети.

- Цветовое и позиционное решение подписи фото `title` - весьма символично.

- Кэширование данных предыдущей сессии работает так: по событию `UIApplication.willTerminateNotification` в классе FickrPhotoListPresenter очищается кэш и массив `photos` "все что дальше" 40 - го элемента (размер порции по умолчанию). Массив `photos` (размером в размер порции по умолчанию) при этом, сохраняется в `UserDefaults` заархивированным. При следующем запуске приложения сохраненные данные извлекаются из `UserDefaults` и в случае если данные удалось корректно восстановить - используем их и соответствующие картинки из кэша.
